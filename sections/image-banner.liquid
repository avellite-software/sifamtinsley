{% comment %}
  Section: Interactive Product Orbit
  - V3 Changes:
    - Corrected orbit path to be visible in the bottom-right.
    - Reversed default animation direction.
    - Improved scaling logic based on position.
    - Added debug background colors for visualization.
{% endcomment %}

<style>
  .orbit-section-{{ section.id }} {
    --animation-duration: {{ section.settings.animation_duration }}s;
    background-color: #f5f5f5;
    position: relative;
    width: 100%;
    min-height: 600px;
    overflow: hidden;
    cursor: grab;
    user-select: none;
  }
  .orbit-section-{{ section.id }}:active {
    cursor: grabbing;
  }

  .orbit-container {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
  }

  .orbit-item {
    position: absolute;
    top: 0;
    left: 0;
    will-change: transform, opacity;
    transform-origin: center center;
  }

  .orbit-item__image {
    display: block;
    max-width: 150px;
    height: auto;
    pointer-events: none;
    filter: drop-shadow(0 10px 15px rgba(0,0,0,0.1));
  }

  /*
    DEBUG COLORS:
    These are the harsh colors you requested for development.
    You can remove these two rules when you are done.
  */
  .orbit-section-{{ section.id }} {
    background-color: #111;
    border: 2px solid cyan;
  }
  .orbit-item {
    background-color: rgba(255, 0, 150, 0.5);
    border-radius: 50%;
  }
  /* --- END DEBUG COLORS --- */


  @media screen and (max-width: 768px) {
    .orbit-section-{{ section.id }} {
      min-height: 500px;
    }
    .orbit-item__image {
      max-width: 100px;
    }
  }
</style>

<div class="orbit-section-{{ section.id }}" data-section-id="{{ section.id }}">
  <div class="orbit-container">
    {%- liquid
      assign product_list = section.settings.product_list
      assign has_products = false
      if product_list.size > 0
        assign has_products = true
      endif
    -%}

    {%- if has_products -%}
      {%- for product in product_list -%}
        <div class="orbit-item">
          {%- liquid
            assign image = product.featured_image
            assign image_height = 300 | divided_by: image.aspect_ratio | round
          -%}
          <img
            src="{{ image | image_url: width: 300 }}"
            alt="{{ image.alt | escape }}"
            class="orbit-item__image"
            loading="lazy"
            width="300"
            height="{{ image_height }}"
          >
        </div>
      {%- endfor -%}
    {%- else -%}
      {%- for i in (1..6) -%}
        <div class="orbit-item">
          <img
            src="https://placehold.co/300x300/png?text=Product+{{ i }}"
            alt="Placeholder product"
            class="orbit-item__image"
            width="300"
            height="300"
          >
        </div>
      {%- endfor -%}
    {%- endif -%}
  </div>
</div>

<script>
  document.addEventListener('DOMContentLoaded', () => {
    const section = document.querySelector('.orbit-section-{{ section.id }}');
    if (!section) return;

    const container = section.querySelector('.orbit-container');
    const items = Array.from(container.querySelectorAll('.orbit-item'));
    if (items.length === 0) return;

    // --- 1. Orbit & Animation Parameters ---
    let currentAngle = 0;
    let isDragging = false;
    let startX = 0;
    let startAngle = 0;
    let animationFrameId;

    const speed = 360 / ({{ section.settings.animation_duration }} * 60);

    // --- 2. Positioning Function ---
    const updatePositions = () => {
      const containerWidth = container.offsetWidth;
      const containerHeight = container.offsetHeight;

      // MODIFICATION: New ellipse parameters to create the bottom-right arc
      const ellipseCenterX = containerWidth * 0.2;
      const ellipseCenterY = -containerHeight * 0.8;
      const ellipseRadiusX = containerWidth * 1.2;
      const ellipseRadiusY = containerHeight * 1.8;

      items.forEach((item, index) => {
        const itemAngleOffset = (360 / items.length) * index;
        const totalAngle = (currentAngle + itemAngleOffset) % 360;
        const angleInRadians = (totalAngle * Math.PI) / 180;

        const x = ellipseCenterX + ellipseRadiusX * Math.cos(angleInRadians);
        const y = ellipseCenterY + ellipseRadiusY * Math.sin(angleInRadians);
        
        // MODIFICATION: New scaling and opacity logic
        // Calculate visibility based on whether the item is within the screen bounds
        let opacity = 0;
        if (x > -150 && x < containerWidth + 150 && y > -150 && y < containerHeight + 150) {
            // Simple fade based on horizontal position for entry/exit
            const fadeInPoint = containerWidth * 0.1;
            const fadeOutPoint = containerWidth * 0.9;
            
            if (x < fadeInPoint) {
                opacity = x / fadeInPoint;
            } else if (x > fadeOutPoint) {
                opacity = (containerWidth - x) / (containerWidth - fadeOutPoint);
            } else {
                opacity = 1;
            }
        }
        
        // Scale is now based on vertical position (lower is bigger)
        let scale = (y / containerHeight) * 1.2;
        scale = Math.max(0.1, Math.min(1.0, scale)); // Clamp scale between 0.1 and 1.0

        item.style.transform = `translate(${x}px, ${y}px) scale(${scale})`;
        item.style.opacity = Math.max(0, opacity); // Clamp opacity
        item.style.zIndex = Math.round(scale * 100);
      });
    };

    // --- 3. Animation Loop ---
    const animate = () => {
      if (!isDragging) {
        currentAngle -= speed; // MODIFICATION: Changed to -= to reverse direction
        updatePositions();
      }
      animationFrameId = requestAnimationFrame(animate);
    };

    // --- 4. Drag Interaction Logic ---
    const startDrag = (e) => {
      isDragging = true;
      startX = e.pageX || e.touches[0].pageX;
      startAngle = currentAngle;
      section.style.cursor = 'grabbing';
    };

    const onDrag = (e) => {
      if (!isDragging) return;
      e.preventDefault();
      const currentX = e.pageX || e.touches[0].pageX;
      const deltaX = currentX - startX;
      
      const angleChange = (deltaX / container.offsetWidth) * 180;
      currentAngle = startAngle + angleChange;
      
      updatePositions();
    };

    const stopDrag = () => {
      if (!isDragging) return;
      isDragging = false;
      section.style.cursor = 'grab';
    };

    // Mouse events
    section.addEventListener('mousedown', startDrag);
    window.addEventListener('mousemove', onDrag);
    window.addEventListener('mouseup', stopDrag);
    section.addEventListener('mouseleave', stopDrag); // Stop if mouse leaves section
    
    // Touch events
    section.addEventListener('touchstart', startDrag, { passive: true });
    window.addEventListener('touchmove', onDrag, { passive: false });
    window.addEventListener('touchend', stopDrag);

    // Initial call and start animation
    updatePositions();
    animate();

    // Re-calculate on resize
    window.addEventListener('resize', updatePositions);
  });
</script>

{% schema %}
{
  "name": "Interactive Orbit",
  "tag": "section",
  "class": "section",
  "settings": [
    {
      "type": "product_list",
      "id": "product_list",
      "label": "Products to display",
      "limit": 12
    },
    {
      "type": "range",
      "id": "animation_duration",
      "min": 20,
      "max": 120,
      "step": 10,
      "unit": "s",
      "label": "Full orbit duration (longer is slower)",
      "default": 80
    }
  ],
  "presets": [
    {
      "name": "Interactive Orbit"
    }
  ]
}
{% endschema %}
