{% comment %}
  Section: Interactive Product Orbit
  - V2 Changes:
    - Added width and height attributes to all <img> tags to prevent layout shift and fix theme-check errors.
{% endcomment %}

<style>
  .orbit-section-{{ section.id }} {
    --animation-duration: {{ section.settings.animation_duration }}s;
    background-color: #f5f5f5;
    position: relative;
    width: 100%;
    min-height: 600px;
    overflow: hidden;
    cursor: grab;
    user-select: none;
  }
  .orbit-section-{{ section.id }}:active {
    cursor: grabbing;
  }

  .orbit-container {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
  }

  .orbit-item {
    position: absolute;
    /* Will be positioned by JS */
    top: 50%;
    left: 50%;
    will-change: transform, opacity;
    transform-origin: center center;
  }

  .orbit-item__image {
    display: block;
    max-width: 150px; /* Base size of the product image */
    height: auto;
    pointer-events: none; /* Prevents image from interfering with drag */
    filter: drop-shadow(0 10px 15px rgba(0,0,0,0.1));
  }

  /* Responsive adjustments */
  @media screen and (max-width: 768px) {
    .orbit-section-{{ section.id }} {
      min-height: 500px;
    }
    .orbit-item__image {
      max-width: 100px;
    }
  }
</style>

<div class="orbit-section-{{ section.id }}" data-section-id="{{ section.id }}">
  <div class="orbit-container">
    {%- liquid
      assign product_list = section.settings.product_list
      assign has_products = false
      if product_list.size > 0
        assign has_products = true
      endif
    -%}

    {%- if has_products -%}
      {%- for product in product_list -%}
        <div class="orbit-item">
          {%- liquid
            assign image = product.featured_image
            assign image_height = 300 | divided_by: image.aspect_ratio | round
          -%}
          <img
            src="{{ image | image_url: width: 300 }}"
            alt="{{ image.alt | escape }}"
            class="orbit-item__image"
            loading="lazy"
            width="300"
            height="{{ image_height }}"
          >
        </div>
      {%- endfor -%}
    {%- else -%}
      {%- comment -%} Fallback for theme editor when no products are selected {%- endcomment -%}
      {%- for i in (1..6) -%}
        <div class="orbit-item">
          <img
            src="https://placehold.co/300x300/png?text=Product+{{ i }}"
            alt="Placeholder product"
            class="orbit-item__image"
            width="300"
            height="300"
          >
        </div>
      {%- endfor -%}
    {%- endif -%}
  </div>
</div>

<script>
  document.addEventListener('DOMContentLoaded', () => {
    const section = document.querySelector('.orbit-section-{{ section.id }}');
    if (!section) return;

    const container = section.querySelector('.orbit-container');
    const items = Array.from(container.querySelectorAll('.orbit-item'));
    if (items.length === 0) return;

    // --- 1. Orbit & Animation Parameters ---
    let currentAngle = 0;
    let isDragging = false;
    let startX = 0;
    let startAngle = 0;
    let animationFrameId;

    const speed = 360 / ({{ section.settings.animation_duration }} * 60); // Degrees per frame

    // --- 2. Positioning Function ---
    const updatePositions = () => {
      const containerWidth = container.offsetWidth;
      const containerHeight = container.offsetHeight;

      // Define the ellipse. Center is off-screen to the top-left.
      const ellipseCenterX = containerWidth * -0.2;
      const ellipseCenterY = containerHeight * -0.5;
      const ellipseRadiusX = containerWidth * 1.1;
      const ellipseRadiusY = containerHeight * 1.5;

      const angleStart = 10; // Starting degree (bottom-ish)
      const angleEnd = 110;   // Ending degree (right-ish)
      const angleRange = angleEnd - angleStart;

      items.forEach((item, index) => {
        const itemAngleOffset = (360 / items.length) * index;
        let totalAngle = (currentAngle + itemAngleOffset) % 360;

        // Convert degrees to radians for Math functions
        const angleInRadians = (totalAngle * Math.PI) / 180;

        const x = ellipseCenterX + ellipseRadiusX * Math.cos(angleInRadians);
        const y = ellipseCenterY + ellipseRadiusY * Math.sin(angleInRadians);
        
        // Calculate scale and opacity based on position in the visible arc
        let scale = 0;
        let opacity = 0;

        if (totalAngle >= angleStart && totalAngle <= angleEnd) {
          const progress = (totalAngle - angleStart) / angleRange; // 0 to 1
          
          // Scale: Largest in the middle (progress 0.5), smallest at ends
          scale = 1 - Math.abs(progress - 0.5) * 1.5;
          scale = Math.max(0, scale); // Clamp at 0

          // Opacity: Fade in and out at the edges
          if (progress < 0.2) { // Fade in
            opacity = progress / 0.2;
          } else if (progress > 0.8) { // Fade out
            opacity = (1 - progress) / 0.2;
          } else {
            opacity = 1;
          }
        }
        
        item.style.transform = `translate(${x}px, ${y}px) scale(${scale})`;
        item.style.opacity = opacity;
        item.style.zIndex = Math.round(scale * 100);
      });
    };

    // --- 3. Animation Loop ---
    const animate = () => {
      if (!isDragging) {
        currentAngle += speed;
        updatePositions();
      }
      animationFrameId = requestAnimationFrame(animate);
    };

    // --- 4. Drag Interaction Logic ---
    const startDrag = (e) => {
      isDragging = true;
      startX = e.pageX || e.touches[0].pageX;
      startAngle = currentAngle;
      container.style.cursor = 'grabbing';
    };

    const onDrag = (e) => {
      if (!isDragging) return;
      const currentX = e.pageX || e.touches[0].pageX;
      const deltaX = currentX - startX;
      
      // Adjust angle based on drag distance. The multiplier controls sensitivity.
      const angleChange = (deltaX / container.offsetWidth) * 180;
      currentAngle = startAngle + angleChange;
      
      updatePositions();
    };

    const stopDrag = () => {
      if (!isDragging) return;
      isDragging = false;
      container.style.cursor = 'grab';
    };

    // Mouse events
    container.addEventListener('mousedown', startDrag);
    window.addEventListener('mousemove', onDrag);
    window.addEventListener('mouseup', stopDrag);
    
    // Touch events
    container.addEventListener('touchstart', startDrag);
    window.addEventListener('touchmove', onDrag);
    window.addEventListener('touchend', stopDrag);

    // Initial call and start animation
    updatePositions();
    animate();
  });
</script>

{% schema %}
{
  "name": "Interactive Orbit",
  "tag": "section",
  "class": "section",
  "settings": [
    {
      "type": "product_list",
      "id": "product_list",
      "label": "Products to display",
      "limit": 12
    },
    {
      "type": "range",
      "id": "animation_duration",
      "min": 20,
      "max": 120,
      "step": 10,
      "unit": "s",
      "label": "Full orbit duration (longer is slower)",
      "default": 80
    }
  ],
  "presets": [
    {
      "name": "Interactive Orbit"
    }
  ]
}
{% endschema %}
