{% comment %}
  Section: Interactive Product Orbit
  - V9 Changes:
    - Set a minimum scale of 0.1 to prevent items from disappearing.
{% endcomment %}

{%- liquid
  comment
    HOW TO ADJUST THE ORBIT:
    - orbit_center_x_multiplier: Controls the horizontal center. A smaller number (e.g., -0.5) moves the orbit's center further to the left.
    - orbit_center_y_multiplier: Controls the vertical center. A smaller number (e.g., -1.0) moves the orbit's center further up.
    - orbit_radius_x_multiplier: Controls the orbit's width. A larger number makes the path wider.
    - orbit_radius_y_multiplier: Controls the orbit's height. A larger number makes the path taller.
  endcomment
  assign orbit_center_x_multiplier = 0.25
  assign orbit_center_y_multiplier = 0.2
  assign orbit_radius_x_multiplier = 0.45
  assign orbit_radius_y_multiplier = 0.25
-%}

<style>
  .orbit-section-{{ section.id }} {
    --animation-duration: {{ section.settings.animation_duration }}s;
    background-color: #111;
    border: 2px solid cyan;
    position: relative;
    width: 100%;
    min-height: 600px;
    overflow: hidden;
    cursor: grab;
    user-select: none;
  }
  .orbit-section-{{ section.id }}:active {
    cursor: grabbing;
  }
  .orbit-container {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
  }
  .orbit-item {
    position: absolute;
    top: 0;
    left: 0;
    will-change: transform, opacity;
    transform-origin: center center;
    background-color: rgba(255, 0, 150, 0.5);
    border-radius: 50%;
    transition: transform 0.3s cubic-bezier(0.25, 0.8, 0.25, 1);
  }
  .orbit-item__image {
    display: block;
    max-width: 450px;
    height: auto;
    pointer-events: none;
    filter: drop-shadow(0 10px 15px rgba(0,0,0,0.1));
  }
  @media screen and (max-width: 768px) {
    .orbit-section-{{ section.id }} {
      min-height: 500px;
    }
    .orbit-item__image {
      max-width: 250px;
    }
  }
</style>

<div
  class="orbit-section-{{ section.id }}"
  data-section-id="{{ section.id }}"
  data-center-x="{{ orbit_center_x_multiplier }}"
  data-center-y="{{ orbit_center_y_multiplier }}"
  data-radius-x="{{ orbit_radius_x_multiplier }}"
  data-radius-y="{{ orbit_radius_y_multiplier }}"
>
  <div class="orbit-container">
    {%- if section.settings.product_list.size > 0 -%}
      {%- for product in section.settings.product_list -%}
        <div class="orbit-item">
          {%- liquid
            assign image = product.featured_image
            assign image_height = 300 | divided_by: image.aspect_ratio | round
          -%}
          <img
            src="{{ image | image_url: width: 300 }}"
            alt="{{ image.alt | escape }}"
            class="orbit-item__image"
            loading="lazy"
            width="300"
            height="{{ image_height }}"
          >
        </div>
      {%- endfor -%}
    {%- else -%}
      {%- for i in (1..6) -%}
        <div class="orbit-item">
          <img
            src="https://placehold.co/300x300/png?text=Product+{{ i }}"
            alt="Placeholder product"
            class="orbit-item__image"
            width="300"
            height="300"
          >
        </div>
      {%- endfor -%}
    {%- endif -%}
  </div>
</div>

<script>
  document.addEventListener('DOMContentLoaded', () => {
    const section = document.querySelector('.orbit-section-{{ section.id }}');
    if (!section) return;

    const container = section.querySelector('.orbit-container');
    const items = Array.from(container.querySelectorAll('.orbit-item'));
    if (items.length === 0) return;

    const centerXMultiplier = parseFloat(section.dataset.centerX);
    const centerYMultiplier = parseFloat(section.dataset.centerY);
    const radiusXMultiplier = parseFloat(section.dataset.radiusX);
    const radiusYMultiplier = parseFloat(section.dataset.radiusY);

    let currentAngle = 0;
    let isDragging = false;
    let isHovering = false;
    let startX = 0;
    let startAngle = 0;
    let animationFrameId;
    const speed = 360 / ({{ section.settings.animation_duration }} * 60);

    const updatePositions = () => {
      const containerWidth = container.offsetWidth;
      const containerHeight = container.offsetHeight;

      const ellipseCenterX = containerWidth * centerXMultiplier;
      const ellipseCenterY = containerHeight * centerYMultiplier;
      const ellipseRadiusX = containerWidth * radiusXMultiplier;
      const ellipseRadiusY = containerHeight * radiusYMultiplier;

      items.forEach((item, index) => {
        const itemAngleOffset = (360 / items.length) * index;
        const totalAngle = (currentAngle + itemAngleOffset) % 360;
        const angleInRadians = (totalAngle * Math.PI) / 180;

        const x = ellipseCenterX + ellipseRadiusX * Math.cos(angleInRadians);
        const y = ellipseCenterY + ellipseRadiusY * Math.sin(angleInRadians);
        
        let scale = (y / containerHeight) * 2.4; 
        // MODIFICATION: Changed minimum scale from 0.4 to 0.1
        scale = Math.max(0.1, Math.min(2.0, scale));

        item.style.transform = `translate(${x}px, ${y}px) scale(${scale})`;
        item.style.opacity = 1;
        item.style.zIndex = Math.round(scale * 100);
        
        item.dataset.x = x;
        item.dataset.y = y;
        item.dataset.scale = scale;
      });
    };

    const animate = () => {
      if (!isDragging && !isHovering) {
        currentAngle -= speed;
        updatePositions();
      }
      animationFrameId = requestAnimationFrame(animate);
    };

    const startDrag = (e) => {
      isDragging = true;
      startX = e.pageX || e.touches[0].pageX;
      startAngle = currentAngle;
      section.style.cursor = 'grabbing';
    };

    const onDrag = (e) => {
      if (!isDragging) return;
      e.preventDefault();
      const currentX = e.pageX || e.touches[0].pageX;
      const deltaX = currentX - startX;
      const angleChange = (deltaX / container.offsetWidth) * -180;
      currentAngle = startAngle + angleChange;
      updatePositions();
    };

    const stopDrag = () => {
      if (!isDragging) return;
      isDragging = false;
      section.style.cursor = 'grab';
    };

    items.forEach(item => {
      item.addEventListener('mouseover', () => {
        isHovering = true;
        const x = parseFloat(item.dataset.x);
        const y = parseFloat(item.dataset.y);
        const scale = parseFloat(item.dataset.scale);
        item.style.transform = `translate(${x}px, ${y}px) scale(${scale * 1.1})`;
      });
      
      item.addEventListener('mouseout', () => {
        isHovering = false;
        const x = parseFloat(item.dataset.x);
        const y = parseFloat(item.dataset.y);
        const scale = parseFloat(item.dataset.scale);
        item.style.transform = `translate(${x}px, ${y}px) scale(${scale})`;
      });
    });

    section.addEventListener('mousedown', startDrag);
    window.addEventListener('mousemove', onDrag);
    window.addEventListener('mouseup', stopDrag);
    section.addEventListener('mouseleave', stopDrag);
    section.addEventListener('touchstart', startDrag, { passive: true });
    window.addEventListener('touchmove', onDrag, { passive: false });
    window.addEventListener('touchend', stopDrag);

    updatePositions();
    animate();
    window.addEventListener('resize', updatePositions);
  });
</script>

{% schema %}
{
  "name": "Interactive Orbit",
  "tag": "section",
  "class": "section",
  "settings": [
    {
      "type": "product_list",
      "id": "product_list",
      "label": "Products to display",
      "limit": 12
    },
    {
      "type": "range",
      "id": "animation_duration",
      "min": 20,
      "max": 120,
      "step": 10,
      "unit": "s",
      "label": "Full orbit duration (longer is slower)",
      "default": 80
    }
  ],
  "presets": [
    {
      "name": "Interactive Orbit"
    }
  ]
}
{% endschema %}
